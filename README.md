# Wave Foundation Model (WFM)

A PyTorch-based foundation model package that implements a novel approach to multi-modal AI through spherical geometry and differential equations.

## Overview

The Wave Foundation Model (WFM) is a unique foundation model architecture that combines:

1. **3D Spherical Mesh Generation** - Creates collision-free spherical meshes for geometric computations
2. **Diffusion-Advection-Reaction Equations** - Implements PDEs over spherical domains with numerical discretization
3. **Multi-Modal Input Processing** - Converts diverse input types into standardized 12×12×3 tensor sequences

## Key Features

- **Collision Avoidance**: Automatically excludes center and pole regions to prevent numerical instabilities
- **Coordinate Transformations**: Seamless conversion between Cartesian and spherical coordinate systems
- **Flexible PDE Framework**: Support for various reaction functions and velocity fields
- **Multi-Modal Inputs**: Handles images, text, numerical data, audio, and graphs
- **GPU Acceleration**: Full PyTorch compatibility with CUDA support
- **Extensible Architecture**: Modular design for easy customization and extension

## Installation

### Prerequisites

- Python 3.12+
- PyTorch 2.0+
- Poetry (for dependency management)

### Install Dependencies

```bash
# Install using Poetry
poetry install

# Or install manually
pip install torch numpy Pillow opencv-python matplotlib scipy
```

### Install Package

```bash
# Development install
poetry install

# Or install in development mode
pip install -e .
```

## Quick Start

### 1. Spherical Mesh Creation

```python
from wfm import SphericalMesh, SphericalMeshBuilder

# Create a basic spherical mesh
mesh = SphericalMesh(
    radius=1.0,
    n_lat=64,      # Number of latitude bands
    n_lon=128,     # Number of longitude points
    exclude_poles=True,
    pole_exclusion_angle=0.1,
    center_exclusion_radius=0.05
)

# Get mesh coordinates
cartesian_coords = mesh.get_mesh_points()
spherical_coords = mesh.get_spherical_coords()

# Use builder for predefined configurations
high_res_mesh = SphericalMeshBuilder.create_high_resolution_mesh()
```

### 2. Differential Equations

```python
from wfm import (
    DiffusionAdvectionReaction, 
    SphericalDiscretizer,
    ReactionFunctions,
    VelocityFields
)

# Define a diffusion-advection-reaction equation
equation = DiffusionAdvectionReaction(
    diffusion_coeff=0.1,
    velocity_field=VelocityFields.solid_body_rotation,
    reaction_function=ReactionFunctions.logistic_growth
)

# Set the mesh
equation.set_mesh(mesh)

# Create discretizer and solve
discretizer = SphericalDiscretizer(mesh, time_step=0.01)
solution = discretizer.discretize_equation(
    equation=equation,
    initial_condition=initial_condition,
    time_steps=100,
    method='explicit_euler'
)
```

### 3. Input Processing

```python
from wfm import InputProcessor, BatchProcessor

# Create input processor for 12×12×3 tensors
processor = InputProcessor(target_shape=(12, 12, 3))

# Process different input types
numerical_tensor = processor.process_input([1.0, 2.0, 3.0], 'numerical')
text_tensor = processor.process_input("Hello, World!", 'text')
image_tensor = processor.process_input("path/to/image.jpg", 'image')

# Batch processing
batch_processor = BatchProcessor(processor)
batch_tensor = batch_processor.process_batch([
    [1.0, 2.0, 3.0],
    "Sample text",
    {"nodes": [0, 1, 2], "edges": [[0, 1], [1, 2]]}
])
```

## Architecture

### Core Components

#### SphericalMesh
- **Purpose**: Generates and manages 3D spherical meshes
- **Features**: 
  - Automatic pole and center exclusion
  - Coordinate system transformations
  - Validity checking for collision avoidance
  - Configurable resolution and exclusion parameters

#### DiffusionAdvectionReaction
- **Purpose**: Defines and solves PDEs over spherical domains
- **Features**:
  - Support for variable diffusion coefficients
  - Customizable velocity fields
  - Flexible reaction functions
  - Spherical coordinate-aware discretization

#### InputProcessor
- **Purpose**: Converts diverse inputs to standardized tensor format
- **Features**:
  - Multi-modal input support (image, text, numerical, audio, graph)
  - Automatic input type detection
  - Batch processing capabilities
  - Configurable output dimensions

### Coordinate Systems

The package uses two coordinate systems:

1. **Cartesian (x, y, z)**: Standard 3D coordinates
2. **Spherical (r, θ, φ)**: 
   - r: Radial distance from center
   - θ: Colatitude (0 to π)
   - φ: Longitude (0 to 2π)

### Mesh Generation

The spherical mesh is generated by:
1. Creating latitude and longitude grids
2. Excluding regions near poles (configurable angle)
3. Excluding center region (configurable radius)
4. Converting to Cartesian coordinates
5. Providing coordinate transformation utilities

## Advanced Usage

### Custom Reaction Functions

```python
def custom_reaction(u, coords, param1=1.0, param2=0.5):
    """Custom reaction function R(u) = param1 * u^2 - param2 * u"""
    return param1 * u**2 - param2 * u

equation = DiffusionAdvectionReaction(
    reaction_function=custom_reaction
)
```

### Custom Velocity Fields

```python
def custom_velocity(coords, strength=1.0):
    """Custom velocity field"""
    x, y, z = coords[:, 0], coords[:, 1], coords[:, 2]
    vx = strength * torch.sin(y)
    vy = strength * torch.cos(x)
    vz = torch.zeros_like(x)
    return torch.stack([vx, vy, vz], dim=1)

equation = DiffusionAdvectionReaction(
    velocity_field=custom_velocity
)
```

### Adaptive Mesh Generation

```python
# Create adaptive mesh based on solution gradients
def create_adaptive_mesh(solution, base_mesh):
    # Implementation for mesh refinement based on solution features
    pass
```

## Examples

### Complete Pipeline Example

```python
from wfm import *

# 1. Create mesh
mesh = SphericalMeshBuilder.create_uniform_mesh(n_lat=32, n_lon=64)

# 2. Define equation
equation = DiffusionAdvectionReaction(
    diffusion_coeff=0.05,
    velocity_field=VelocityFields.zonal_flow,
    reaction_function=ReactionFunctions.cubic_reaction
)

# 3. Process input
processor = InputProcessor(target_shape=(12, 12, 3))
input_tensor = processor.process_input([0.1, 0.2, 0.3, 0.4, 0.5])

# 4. Solve equation
discretizer = SphericalDiscretizer(mesh, time_step=0.01)
solution = discretizer.discretize_equation(
    equation=equation,
    initial_condition=initial_condition,
    time_steps=50
)

# 5. Analyze results
final_state = solution[-1]
print(f"Final solution range: [{final_state.min():.3f}, {final_state.max():.3f}]")
```

### Visualization Example

```python
import matplotlib.pyplot as plt

# Visualize solution evolution
coords = mesh.get_mesh_points()
x, y = coords[:, 0], coords[:, 1]

fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Initial condition
scatter0 = axes[0].scatter(x, y, c=solution[0], cmap='viridis', s=10)
axes[0].set_title('Initial Condition')

# Middle time
mid_time = solution.shape[0] // 2
scatter1 = axes[1].scatter(x, y, c=solution[mid_time], cmap='viridis', s=10)
axes[1].set_title(f'Time Step {mid_time}')

# Final time
scatter2 = axes[2].scatter(x, y, c=solution[-1], cmap='viridis', s=10)
axes[2].set_title('Final Time')

plt.tight_layout()
plt.show()
```

## Performance Considerations

### GPU Acceleration
- All tensors are automatically moved to GPU if available
- Use `device` parameter to control tensor placement
- Batch processing for efficient GPU utilization

### Memory Management
- Mesh generation scales with O(n_lat × n_lon)
- Solution storage scales with O(time_steps × n_points)
- Use `max_sequence_length` to limit memory usage

### Numerical Stability
- Pole exclusion prevents coordinate singularities
- Center exclusion avoids division by zero
- Configurable exclusion parameters for different applications

## Extending the Package

### Adding New Input Types

```python
class CustomProcessor:
    def __init__(self, target_shape, device):
        self.target_shape = target_shape
        self.device = device
    
    def process(self, custom_input):
        # Custom processing logic
        return processed_tensor

# Register with InputProcessor
processor.custom_processor = CustomProcessor(processor.target_shape, processor.device)
```

### Adding New Reaction Functions

```python
class CustomReactionFunctions:
    @staticmethod
    def new_reaction(u, coords, **params):
        # Custom reaction implementation
        return reaction_result

# Use in equation
equation = DiffusionAdvectionReaction(
    reaction_function=CustomReactionFunctions.new_reaction
)
```

## Testing

Run the demonstration script to verify installation:

```bash
python examples/foundation_model_demo.py
```

This will:
1. Create spherical meshes
2. Solve differential equations
3. Process various input types
4. Generate visualizations
5. Demonstrate integration

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests if applicable
5. Submit a pull request

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Citation

If you use this package in your research, please cite:

```bibtex
@software{wfm2024,
  title={Wave Foundation Model: A PyTorch-based foundation model with spherical geometry},
  author={Davide Riva},
  year={2024},
  url={https://github.com/dave-shore/wfm}
}
```

## Support

For questions and support:
- Open an issue on GitHub
- Check the examples directory
- Review the inline documentation

## Roadmap

- [ ] Advanced mesh refinement algorithms
- [ ] Implicit time integration methods
- [ ] Parallel processing support
- [ ] More sophisticated input encodings
- [ ] Integration with popular ML frameworks
- [ ] Pre-trained model weights
- [ ] Web interface for interactive exploration
